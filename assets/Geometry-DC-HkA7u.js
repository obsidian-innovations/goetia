import{D as st,a as y,E as L,B as it}from"./index-Dwzt30Gb.js";const P=Object.create(null),V=Object.create(null);function $(s,t){let e=V[s];return e===void 0&&(P[t]===void 0&&(P[t]=1),V[s]=e=P[t]++),e}let x;function rt(){return(!x||x?.isContextLost())&&(x=st.get().createCanvas().getContext("webgl",{})),x}let E;function nt(){if(!E){E="mediump";const s=rt();s&&s.getShaderPrecisionFormat&&(E=s.getShaderPrecisionFormat(s.FRAGMENT_SHADER,s.HIGH_FLOAT).precision?"highp":"mediump")}return E}function ot(s,t,e){return t?s:e?(s=s.replace("out vec4 finalColor;",""),`

        #ifdef GL_ES // This checks if it is WebGL1
        #define in varying
        #define finalColor gl_FragColor
        #define texture texture2D
        #endif
        ${s}
        `):`

        #ifdef GL_ES // This checks if it is WebGL1
        #define in attribute
        #define out varying
        #endif
        ${s}
        `}function at(s,t,e){const i=e?t.maxSupportedFragmentPrecision:t.maxSupportedVertexPrecision;if(s.substring(0,9)!=="precision"){let r=e?t.requestedFragmentPrecision:t.requestedVertexPrecision;return r==="highp"&&i!=="highp"&&(r="mediump"),`precision ${r} float;
${s}`}else if(i!=="highp"&&s.substring(0,15)==="precision highp")return s.replace("precision highp","precision mediump");return s}function ut(s,t){return t?`#version 300 es
${s}`:s}const ct={},lt={};function dt(s,{name:t="pixi-program"},e=!0){t=t.replace(/\s+/g,"-"),t+=e?"-fragment":"-vertex";const i=e?ct:lt;return i[t]?(i[t]++,t+=`-${i[t]}`):i[t]=1,s.indexOf("#define SHADER_NAME")!==-1?s:`${`#define SHADER_NAME ${t}`}
${s}`}function ht(s,t){return t?s.replace("#version 300 es",""):s}const v={stripVersion:ht,ensurePrecision:at,addProgramDefines:ot,setProgramName:dt,insertVersion:ut},b=Object.create(null),X=class R{constructor(t){t={...R.defaultOptions,...t};const e=t.fragment.indexOf("#version 300 es")!==-1,i={stripVersion:e,ensurePrecision:{requestedFragmentPrecision:t.preferredFragmentPrecision,requestedVertexPrecision:t.preferredVertexPrecision,maxSupportedVertexPrecision:"highp",maxSupportedFragmentPrecision:nt()},setProgramName:{name:t.name},addProgramDefines:e,insertVersion:e};let r=t.fragment,n=t.vertex;Object.keys(v).forEach(a=>{const o=i[a];r=v[a](r,o,!0),n=v[a](n,o,!1)}),this.fragment=r,this.vertex=n,this.transformFeedbackVaryings=t.transformFeedbackVaryings,this._key=$(`${this.vertex}:${this.fragment}`,"gl-program")}destroy(){this.fragment=null,this.vertex=null,this._attributeData=null,this._uniformData=null,this._uniformBlockData=null,this.transformFeedbackVaryings=null,b[this._cacheKey]=null}static from(t){const e=`${t.vertex}:${t.fragment}`;return b[e]||(b[e]=new R(t),b[e]._cacheKey=e),b[e]}};X.defaultOptions={preferredVertexPrecision:"highp",preferredFragmentPrecision:"mediump"};let W=X;const B={uint8x2:{size:2,stride:2,normalised:!1},uint8x4:{size:4,stride:4,normalised:!1},sint8x2:{size:2,stride:2,normalised:!1},sint8x4:{size:4,stride:4,normalised:!1},unorm8x2:{size:2,stride:2,normalised:!0},unorm8x4:{size:4,stride:4,normalised:!0},snorm8x2:{size:2,stride:2,normalised:!0},snorm8x4:{size:4,stride:4,normalised:!0},uint16x2:{size:2,stride:4,normalised:!1},uint16x4:{size:4,stride:8,normalised:!1},sint16x2:{size:2,stride:4,normalised:!1},sint16x4:{size:4,stride:8,normalised:!1},unorm16x2:{size:2,stride:4,normalised:!0},unorm16x4:{size:4,stride:8,normalised:!0},snorm16x2:{size:2,stride:4,normalised:!0},snorm16x4:{size:4,stride:8,normalised:!0},float16x2:{size:2,stride:4,normalised:!1},float16x4:{size:4,stride:8,normalised:!1},float32:{size:1,stride:4,normalised:!1},float32x2:{size:2,stride:8,normalised:!1},float32x3:{size:3,stride:12,normalised:!1},float32x4:{size:4,stride:16,normalised:!1},uint32:{size:1,stride:4,normalised:!1},uint32x2:{size:2,stride:8,normalised:!1},uint32x3:{size:3,stride:12,normalised:!1},uint32x4:{size:4,stride:16,normalised:!1},sint32:{size:1,stride:4,normalised:!1},sint32x2:{size:2,stride:8,normalised:!1},sint32x3:{size:3,stride:12,normalised:!1},sint32x4:{size:4,stride:16,normalised:!1}};function ft(s){return B[s]??B.float32}const mt={f32:"float32","vec2<f32>":"float32x2","vec3<f32>":"float32x3","vec4<f32>":"float32x4",vec2f:"float32x2",vec3f:"float32x3",vec4f:"float32x4",i32:"sint32","vec2<i32>":"sint32x2","vec3<i32>":"sint32x3","vec4<i32>":"sint32x4",vec2i:"sint32x2",vec3i:"sint32x3",vec4i:"sint32x4",u32:"uint32","vec2<u32>":"uint32x2","vec3<u32>":"uint32x3","vec4<u32>":"uint32x4",vec2u:"uint32x2",vec3u:"uint32x3",vec4u:"uint32x4",bool:"uint32","vec2<bool>":"uint32x2","vec3<bool>":"uint32x3","vec4<bool>":"uint32x4"},Y=/@location\((\d+)\)\s+([a-zA-Z0-9_]+)\s*:\s*([a-zA-Z0-9_<>]+)(?:,|\s|\)|$)/g;function j(s,t){let e;for(;(e=Y.exec(s))!==null;){const i=mt[e[3]]??"float32";t[e[2]]={location:parseInt(e[1],10),format:i,stride:ft(i).stride,offset:0,instance:!1,start:0}}Y.lastIndex=0}function pt(s){return s.replace(/\/\/.*$/gm,"").replace(/\/\*[\s\S]*?\*\//g,"")}function gt({source:s,entryPoint:t}){const e={},i=pt(s),r=i.indexOf(`fn ${t}(`);if(r===-1)return e;const n=i.indexOf("->",r);if(n===-1)return e;const a=i.substring(r,n);if(j(a,e),Object.keys(e).length===0){const o=a.match(/\(\s*\w+\s*:\s*(\w+)/);if(o){const l=o[1],d=new RegExp(`struct\\s+${l}\\s*\\{([^}]+)\\}`,"s"),u=i.match(d);u&&j(u[1],e)}}return e}function T(s){const t=/(^|[^/])@(group|binding)\(\d+\)[^;]+;/g,e=/@group\((\d+)\)/,i=/@binding\((\d+)\)/,r=/var(<[^>]+>)? (\w+)/,n=/:\s*([\w<>]+)/,a=/struct\s+(\w+)\s*{([^}]+)}/g,o=/(\w+)\s*:\s*([\w\<\>]+)/g,l=/struct\s+(\w+)/,d=s.match(t)?.map(c=>({group:parseInt(c.match(e)[1],10),binding:parseInt(c.match(i)[1],10),name:c.match(r)[2],isUniform:c.match(r)[1]==="<uniform>",type:c.match(n)[1]}));if(!d)return{groups:[],structs:[]};const u=s.match(a)?.map(c=>{const h=c.match(l)[1],f=c.match(o).reduce((p,J)=>{const[tt,et]=J.split(":");return p[tt.trim()]=et.trim(),p},{});return f?{name:h,members:f}:null}).filter(({name:c})=>d.some(h=>h.type===c||h.type.includes(`<${c}>`)))??[];return{groups:d,structs:u}}var g=(s=>(s[s.VERTEX=1]="VERTEX",s[s.FRAGMENT=2]="FRAGMENT",s[s.COMPUTE=4]="COMPUTE",s))(g||{});function yt({groups:s}){const t=[];for(let e=0;e<s.length;e++){const i=s[e];t[i.group]||(t[i.group]=[]),i.isUniform?t[i.group].push({binding:i.binding,visibility:g.VERTEX|g.FRAGMENT,buffer:{type:"uniform"}}):i.type==="sampler"?t[i.group].push({binding:i.binding,visibility:g.FRAGMENT,sampler:{type:"filtering"}}):i.type==="texture_2d"||i.type.startsWith("texture_2d<")?t[i.group].push({binding:i.binding,visibility:g.FRAGMENT,texture:{sampleType:"float",viewDimension:"2d",multisampled:!1}}):i.type==="texture_2d_array"||i.type.startsWith("texture_2d_array<")?t[i.group].push({binding:i.binding,visibility:g.FRAGMENT,texture:{sampleType:"float",viewDimension:"2d-array",multisampled:!1}}):(i.type==="texture_cube"||i.type.startsWith("texture_cube<"))&&t[i.group].push({binding:i.binding,visibility:g.FRAGMENT,texture:{sampleType:"float",viewDimension:"cube",multisampled:!1}})}for(let e=0;e<t.length;e++)t[e]||(t[e]=[]);return t}function bt({groups:s}){const t=[];for(let e=0;e<s.length;e++){const i=s[e];t[i.group]||(t[i.group]={}),t[i.group][i.name]=i.binding}return t}function _t(s,t){const e=new Set,i=new Set,r=[...s.structs,...t.structs].filter(a=>e.has(a.name)?!1:(e.add(a.name),!0)),n=[...s.groups,...t.groups].filter(a=>{const o=`${a.name}-${a.binding}`;return i.has(o)?!1:(i.add(o),!0)});return{structs:r,groups:n}}const _=Object.create(null);class A{constructor(t){this._layoutKey=0,this._attributeLocationsKey=0;const{fragment:e,vertex:i,layout:r,gpuLayout:n,name:a}=t;if(this.name=a,this.fragment=e,this.vertex=i,e.source===i.source){const o=T(e.source);this.structsAndGroups=o}else{const o=T(i.source),l=T(e.source);this.structsAndGroups=_t(o,l)}this.layout=r??bt(this.structsAndGroups),this.gpuLayout=n??yt(this.structsAndGroups),this.autoAssignGlobalUniforms=this.layout[0]?.globalUniforms!==void 0,this.autoAssignLocalUniforms=this.layout[1]?.localUniforms!==void 0,this._generateProgramKey()}_generateProgramKey(){const{vertex:t,fragment:e}=this,i=t.source+e.source+t.entryPoint+e.entryPoint;this._layoutKey=$(i,"program")}get attributeData(){return this._attributeData??(this._attributeData=gt(this.vertex)),this._attributeData}destroy(){this.gpuLayout=null,this.layout=null,this.structsAndGroups=null,this.fragment=null,this.vertex=null,_[this._cacheKey]=null}static from(t){const e=`${t.vertex.source}:${t.fragment.source}:${t.fragment.entryPoint}:${t.vertex.entryPoint}`;return _[e]||(_[e]=new A(t),_[e]._cacheKey=e),_[e]}}const K=["f32","i32","vec2<f32>","vec3<f32>","vec4<f32>","mat2x2<f32>","mat3x3<f32>","mat4x4<f32>","mat3x2<f32>","mat4x2<f32>","mat2x3<f32>","mat4x3<f32>","mat2x4<f32>","mat3x4<f32>","vec2<i32>","vec3<i32>","vec4<i32>"],xt=K.reduce((s,t)=>(s[t]=!0,s),{});function Et(s,t){switch(s){case"f32":return 0;case"vec2<f32>":return new Float32Array(2*t);case"vec3<f32>":return new Float32Array(3*t);case"vec4<f32>":return new Float32Array(4*t);case"mat2x2<f32>":return new Float32Array([1,0,0,1]);case"mat3x3<f32>":return new Float32Array([1,0,0,0,1,0,0,0,1]);case"mat4x4<f32>":return new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1])}return null}const U=class H{constructor(t,e){this._touched=0,this.uid=y("uniform"),this._resourceType="uniformGroup",this._resourceId=y("resource"),this.isUniformGroup=!0,this._dirtyId=0,this.destroyed=!1,e={...H.defaultOptions,...e},this.uniformStructures=t;const i={};for(const r in t){const n=t[r];if(n.name=r,n.size=n.size??1,!xt[n.type]){const a=n.type.match(/^array<(\w+(?:<\w+>)?),\s*(\d+)>$/);if(a){const[,o,l]=a;throw new Error(`Uniform type ${n.type} is not supported. Use type: '${o}', size: ${l} instead.`)}throw new Error(`Uniform type ${n.type} is not supported. Supported uniform types are: ${K.join(", ")}`)}n.value??(n.value=Et(n.type,n.size)),i[r]=n.value}this.uniforms=i,this._dirtyId=1,this.ubo=e.ubo,this.isStatic=e.isStatic,this._signature=$(Object.keys(i).map(r=>`${r}-${t[r].type}`).join("-"),"uniform-group")}update(){this._dirtyId++}};U.defaultOptions={ubo:!1,isStatic:!1};let At=U;class F{constructor(t){this.resources=Object.create(null),this._dirty=!0;let e=0;for(const i in t){const r=t[i];this.setResource(r,e++)}this._updateKey()}_updateKey(){if(!this._dirty)return;this._dirty=!1;const t=[];let e=0;for(const i in this.resources)t[e++]=this.resources[i]._resourceId;this._key=t.join("|")}setResource(t,e){const i=this.resources[e];t!==i&&(i&&t.off?.("change",this.onResourceChange,this),t.on?.("change",this.onResourceChange,this),this.resources[e]=t,this._dirty=!0)}getResource(t){return this.resources[t]}_touch(t,e){const i=this.resources;for(const r in i)i[r]._gcLastUsed=t,i[r]._touched=e}destroy(){const t=this.resources;for(const e in t)t[e]?.off?.("change",this.onResourceChange,this);this.resources=null}onResourceChange(t){if(this._dirty=!0,t.destroyed){const e=this.resources;for(const i in e)e[i]===t&&(e[i]=null)}else this._updateKey()}}var I=(s=>(s[s.WEBGL=1]="WEBGL",s[s.WEBGPU=2]="WEBGPU",s[s.CANVAS=4]="CANVAS",s[s.BOTH=3]="BOTH",s))(I||{});class k extends L{constructor(t){super(),this.uid=y("shader"),this._uniformBindMap=Object.create(null),this._ownedBindGroups=[],this._destroyed=!1;let{gpuProgram:e,glProgram:i,groups:r,resources:n,compatibleRenderers:a,groupMap:o}=t;this.gpuProgram=e,this.glProgram=i,a===void 0&&(a=0,e&&(a|=I.WEBGPU),i&&(a|=I.WEBGL)),this.compatibleRenderers=a;const l={};if(!n&&!r&&(n={}),n&&r)throw new Error("[Shader] Cannot have both resources and groups");if(!e&&r&&!o)throw new Error("[Shader] No group map or WebGPU shader provided - consider using resources instead.");if(!e&&r&&o)for(const d in o)for(const u in o[d]){const c=o[d][u];l[c]={group:d,binding:u,name:c}}else if(e&&r&&!o){const d=e.structsAndGroups.groups;o={},d.forEach(u=>{o[u.group]=o[u.group]||{},o[u.group][u.binding]=u.name,l[u.name]=u})}else if(n){r={},o={},e&&e.structsAndGroups.groups.forEach(c=>{o[c.group]=o[c.group]||{},o[c.group][c.binding]=c.name,l[c.name]=c});let d=0;for(const u in n)l[u]||(r[99]||(r[99]=new F,this._ownedBindGroups.push(r[99])),l[u]={group:99,binding:d,name:u},o[99]=o[99]||{},o[99][d]=u,d++);for(const u in n){const c=u;let h=n[u];!h.source&&!h._resourceType&&(h=new At(h));const f=l[c];f&&(r[f.group]||(r[f.group]=new F,this._ownedBindGroups.push(r[f.group])),r[f.group].setResource(h,f.binding))}}this.groups=r,this._uniformBindMap=o,this.resources=this._buildResourceAccessor(r,l)}addResource(t,e,i){var r,n;(r=this._uniformBindMap)[e]||(r[e]={}),(n=this._uniformBindMap[e])[i]||(n[i]=t),this.groups[e]||(this.groups[e]=new F,this._ownedBindGroups.push(this.groups[e]))}_buildResourceAccessor(t,e){const i={};for(const r in e){const n=e[r];Object.defineProperty(i,n.name,{get(){return t[n.group].getResource(n.binding)},set(a){t[n.group].setResource(a,n.binding)}})}return i}destroy(t=!1){this._destroyed||(this._destroyed=!0,this.emit("destroy",this),t&&(this.gpuProgram?.destroy(),this.glProgram?.destroy()),this.gpuProgram=null,this.glProgram=null,this.removeAllListeners(),this._uniformBindMap=null,this._ownedBindGroups.forEach(e=>{e.destroy()}),this._ownedBindGroups=null,this.resources=null,this.groups=null)}static from(t){const{gpu:e,gl:i,...r}=t;let n,a;return e&&(n=A.from(e)),i&&(a=W.from(i)),new k({gpuProgram:n,glProgram:a,...r})}}const Pt={normal:0,add:1,multiply:2,screen:3,overlay:4,erase:5,"normal-npm":6,"add-npm":7,"screen-npm":8,min:9,max:10},w=0,S=1,D=2,G=3,M=4,O=5,C=class q{constructor(){this.data=0,this.blendMode="normal",this.polygonOffset=0,this.blend=!0,this.depthMask=!0}get blend(){return!!(this.data&1<<w)}set blend(t){!!(this.data&1<<w)!==t&&(this.data^=1<<w)}get offsets(){return!!(this.data&1<<S)}set offsets(t){!!(this.data&1<<S)!==t&&(this.data^=1<<S)}set cullMode(t){if(t==="none"){this.culling=!1;return}this.culling=!0,this.clockwiseFrontFace=t==="front"}get cullMode(){return this.culling?this.clockwiseFrontFace?"front":"back":"none"}get culling(){return!!(this.data&1<<D)}set culling(t){!!(this.data&1<<D)!==t&&(this.data^=1<<D)}get depthTest(){return!!(this.data&1<<G)}set depthTest(t){!!(this.data&1<<G)!==t&&(this.data^=1<<G)}get depthMask(){return!!(this.data&1<<O)}set depthMask(t){!!(this.data&1<<O)!==t&&(this.data^=1<<O)}get clockwiseFrontFace(){return!!(this.data&1<<M)}set clockwiseFrontFace(t){!!(this.data&1<<M)!==t&&(this.data^=1<<M)}get blendMode(){return this._blendMode}set blendMode(t){this.blend=t!=="none",this._blendMode=t,this._blendModeId=Pt[t]||0}get polygonOffset(){return this._polygonOffset}set polygonOffset(t){this.offsets=!!t,this._polygonOffset=t}toString(){return`[pixi.js/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]`}static for2d(){const t=new q;return t.depthTest=!1,t.blend=!0,t}};C.default2d=C.for2d();let vt=C;const Q=class z extends k{constructor(t){t={...z.defaultOptions,...t},super(t),this.enabled=!0,this._state=vt.for2d(),this.blendMode=t.blendMode,this.padding=t.padding,typeof t.antialias=="boolean"?this.antialias=t.antialias?"on":"off":this.antialias=t.antialias,this.resolution=t.resolution,this.blendRequired=t.blendRequired,this.clipToViewport=t.clipToViewport,this.addResource("uTexture",0,1),t.blendRequired&&this.addResource("uBackTexture",0,3)}apply(t,e,i,r){t.applyFilter(this,e,i,r)}get blendMode(){return this._state.blendMode}set blendMode(t){this._state.blendMode=t}static from(t){const{gpu:e,gl:i,...r}=t;let n,a;return e&&(n=A.from(e)),i&&(a=W.from(i)),new z({gpuProgram:n,glProgram:a,...r})}};Q.defaultOptions={blendMode:"normal",resolution:1,padding:0,antialias:"off",blendRequired:!1,clipToViewport:!0};let St=Q;var m=(s=>(s[s.MAP_READ=1]="MAP_READ",s[s.MAP_WRITE=2]="MAP_WRITE",s[s.COPY_SRC=4]="COPY_SRC",s[s.COPY_DST=8]="COPY_DST",s[s.INDEX=16]="INDEX",s[s.VERTEX=32]="VERTEX",s[s.UNIFORM=64]="UNIFORM",s[s.STORAGE=128]="STORAGE",s[s.INDIRECT=256]="INDIRECT",s[s.QUERY_RESOLVE=512]="QUERY_RESOLVE",s[s.STATIC=1024]="STATIC",s))(m||{});class N extends L{constructor(t){let{data:e,size:i}=t;const{usage:r,label:n,shrinkToFit:a}=t;super(),this._gpuData=Object.create(null),this._gcLastUsed=-1,this.autoGarbageCollect=!0,this.uid=y("buffer"),this._resourceType="buffer",this._resourceId=y("resource"),this._touched=0,this._updateID=1,this._dataInt32=null,this.shrinkToFit=!0,this.destroyed=!1,e instanceof Array&&(e=new Float32Array(e)),this._data=e,i??(i=e?.byteLength);const o=!!e;this.descriptor={size:i,usage:r,mappedAtCreation:o,label:n},this.shrinkToFit=a??!0}get data(){return this._data}set data(t){this.setDataWithSize(t,t.length,!0)}get dataInt32(){return this._dataInt32||(this._dataInt32=new Int32Array(this.data.buffer)),this._dataInt32}get static(){return!!(this.descriptor.usage&m.STATIC)}set static(t){t?this.descriptor.usage|=m.STATIC:this.descriptor.usage&=~m.STATIC}setDataWithSize(t,e,i){if(this._updateID++,this._updateSize=e*t.BYTES_PER_ELEMENT,this._data===t){i&&this.emit("update",this);return}const r=this._data;if(this._data=t,this._dataInt32=null,!r||r.length!==t.length){!this.shrinkToFit&&r&&t.byteLength<r.byteLength?i&&this.emit("update",this):(this.descriptor.size=t.byteLength,this._resourceId=y("resource"),this.emit("change",this));return}i&&this.emit("update",this)}update(t){this._updateSize=t??this._updateSize,this._updateID++,this.emit("update",this)}unload(){this.emit("unload",this);for(const t in this._gpuData)this._gpuData[t]?.destroy();this._gpuData=Object.create(null)}destroy(){this.destroyed=!0,this.unload(),this.emit("destroy",this),this.emit("change",this),this._data=null,this.descriptor=null,this.removeAllListeners()}}function Z(s,t){if(!(s instanceof N)){let e=t?m.INDEX:m.VERTEX;s instanceof Array&&(t?(s=new Uint32Array(s),e=m.INDEX|m.COPY_DST):(s=new Float32Array(s),e=m.VERTEX|m.COPY_DST)),s=new N({data:s,label:t?"index-mesh-buffer":"vertex-mesh-buffer",usage:e})}return s}function Tt(s,t,e){const i=s.getAttribute(t);if(!i)return e.minX=0,e.minY=0,e.maxX=0,e.maxY=0,e;const r=i.buffer.data;let n=1/0,a=1/0,o=-1/0,l=-1/0;const d=r.BYTES_PER_ELEMENT,u=(i.offset||0)/d,c=(i.stride||8)/d;for(let h=u;h<r.length;h+=c){const f=r[h],p=r[h+1];f>o&&(o=f),p>l&&(l=p),f<n&&(n=f),p<a&&(a=p)}return e.minX=n,e.minY=a,e.maxX=o,e.maxY=l,e}function Ft(s){return(s instanceof N||Array.isArray(s)||s.BYTES_PER_ELEMENT)&&(s={buffer:s}),s.buffer=Z(s.buffer,!1),s}class Dt extends L{constructor(t={}){super(),this._gpuData=Object.create(null),this.autoGarbageCollect=!0,this._gcLastUsed=-1,this.uid=y("geometry"),this._layoutKey=0,this.instanceCount=1,this._bounds=new it,this._boundsDirty=!0;const{attributes:e,indexBuffer:i,topology:r}=t;if(this.buffers=[],this.attributes={},e)for(const n in e)this.addAttribute(n,e[n]);this.instanceCount=t.instanceCount??1,i&&this.addIndex(i),this.topology=r||"triangle-list"}onBufferUpdate(){this._boundsDirty=!0,this.emit("update",this)}getAttribute(t){return this.attributes[t]}getIndex(){return this.indexBuffer}getBuffer(t){return this.getAttribute(t).buffer}getSize(){for(const t in this.attributes){const e=this.attributes[t];return e.buffer.data.length/(e.stride/4||e.size)}return 0}addAttribute(t,e){const i=Ft(e);this.buffers.indexOf(i.buffer)===-1&&(this.buffers.push(i.buffer),i.buffer.on("update",this.onBufferUpdate,this),i.buffer.on("change",this.onBufferUpdate,this)),this.attributes[t]=i}addIndex(t){this.indexBuffer=Z(t,!0),this.buffers.push(this.indexBuffer)}get bounds(){return this._boundsDirty?(this._boundsDirty=!1,Tt(this,"aPosition",this._bounds)):this._bounds}unload(){this.emit("unload",this);for(const t in this._gpuData)this._gpuData[t]?.destroy();this._gpuData=Object.create(null)}destroy(t=!1){this.emit("destroy",this),this.removeAllListeners(),t&&this.buffers.forEach(e=>e.destroy()),this.unload(),this.indexBuffer?.destroy(),this.attributes=null,this.buffers=null,this.indexBuffer=null,this._bounds=null}}export{F as B,St as F,W as G,I as R,vt as S,At as U,N as a,m as b,$ as c,k as d,Dt as e,rt as f,ft as g,A as h};
